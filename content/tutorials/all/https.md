---
title: "HTTPS"
aliases:
    - tutorials/all/https.html
    - tutorials/all/https.md
    - chapter/tutorials/all/https
---

At present, basic HTTP/S Server and Client functionality is available. More features will be implemented in the near future. This page will be updated in line with these features.

Full info on HTTP/S Server/Client can be found within [HTTPS page](http://localhost:1313/firmwareapi/pycom/network/https/) page of the Firmware API Reference.

## HTTP Server

In the following example, an HTTP webserver will be created, using [`HTTP_Server`](http://localhost:1313/firmwareapi/pycom/network/https/server/) module. The color (`RED`, `GREEN`, `BLUE` or `OFF`) of the LED can be modified through a web or mobile client:

```python
import pycom
from network import WLAN
from network import HTTP_Server

# The callback that handles the responses generated from the requests sent to a HTTP/S Server
def server_callback(uri, method, headers, body, new_uri, status):
    if(uri == '/buttons/red'):
        pycom.rgbled(0x7f0000)
    if (uri == '/buttons/green'):
        pycom.rgbled(0x007f00)
    if (uri == '/buttons/blue'):
        pycom.rgbled(0x0000ff)
    if (uri == '/buttons/off'):
        pycom.rgbled(0x000000)

# Connect to the network
wlan = WLAN(mode=WLAN.STA)
wlan.connect('your-ssid', auth=(WLAN.WPA2, 'your-key'))
while not wlan.isconnected():
    pass
print(wlan.ifconfig())

# Initiate LED as turned off
pycom.heartbeat(0)
pycom.rgbled(0x000000)

# Initilise an HTTP Server
HTTP_Server.init()

# Define html values
main_html = 'Choose the Pycom RGB Color</br>'
main_html += '<input type="button" value="RED" onclick="window.location.href=\'buttons/red\';"/>'
main_html += '<input type="button" value="GREEN" onclick="window.location.href=\'buttons/green\';"/>'
main_html += '<input type="button" value="BLUE" onclick="window.location.href=\'buttons/blue\';"/>'
main_html += '<input type="button" value="OFF" onclick="window.location.href=\'buttons/off\';"/>'
redirect_html = '<meta http-equiv = "refresh" content = "0; url = /buttons" />'

# Create resources
button = HTTP_Server.add_resource('/buttons', value=main_html)
button_red = HTTP_Server.add_resource('/buttons/red', value=redirect_html)
button_green = HTTP_Server.add_resource('/buttons/green', value=redirect_html)
button_blue = HTTP_Server.add_resource('/buttons/blue', value=redirect_html)
button_off = HTTP_Server.add_resource('/buttons/off', value=redirect_html)

# Register resource request handlers
button.register_request_handler(HTTP_Server.GET, callback=server_callback)
button_red.register_request_handler(HTTP_Server.GET, callback=server_callback)
button_green.register_request_handler(HTTP_Server.GET, callback=server_callback)
button_blue.register_request_handler(HTTP_Server.GET, callback=server_callback)
button_off.register_request_handler(HTTP_Server.GET, callback=server_callback)
```

## HTTPS Server

To create an HTTPS (HTTP Secure or HTTP over TLS/SSL) Server using `HTTP_Server` module, a `keyfile` and a `certfile` must to be generated, and placed into `/flash/cert/` folder on the device. The simplest is to create a self-signed certificate, which can be generated by using OpenSSL command line tool: 

```
openssl req -newkey rsa:2048 -nodes -keyout prvtkey.pem -x509 -days 365 -out cacert.pem -subj "/CN=Pycom HTTPS Server"
```

To enable HTTPS capabilities, port must be set to `443`, `keyfile` and `certfile` paths must be added:

```python
# Init HTTPS Server
HTTP_Server.init(port=443, keyfile='/flash/cert/prvtkey.pem', certfile='/flash/cert/cacert.pem')
```

After initiating an HTTPS Server, it will automatically handle the whole SSL handshake process, in case of a request is coming from a Client. From this point, there is no difference between the HTTP and HTTPS Server methods usage.

## HTTP Client

For testing the capabilities of [`HTTP_Client`](http://localhost:1313/firmwareapi/pycom/network/https/client/) module a great way is to use Request & Response Service of http://httpbin.org/. In the example below, a quick example demonstrates using of `GET`, `POST`, `PUT` and `DELETE` methods:

```python
from network import WLAN
from network import HTTP_Client

# The callback that handles the responses generated from the requests sent to a HTTP/S Server
def client_callback(status, headers, body):
    print("Status Code: {}".format(status))
    for key, value in headers.items(): 
        print(key, ":", value) 
    print("Body: {}".format(body))

# Connect to the network
wlan = WLAN(mode=WLAN.STA)
wlan.connect('your-ssid', auth=(WLAN.WPA2, 'your-key'))
while not wlan.isconnected():
    pass
print(wlan.ifconfig())

# Initialize HTTP Client
HTTP_Client.init("http://httpbin.org/get", callback=client_callback)
# Send request with GET method
HTTP_Client.send_request(method=HTTP_Client.GET)

# Set POST
HTTP_Client.url("http://httpbin.org/post")
HTTP_Client.send_request(method=HTTP_Client.POST, body='post data')

# Set PUT
HTTP_Client.url("http://httpbin.org/put")
HTTP_Client.send_request(method=HTTP_Client.PUT, body='put data')

# Set DELETE
HTTP_Client.url("http://httpbin.org/delete")
HTTP_Client.send_request(method=HTTP_Client.DELETE)

# Optionally deinit Client
HTTP_Client.deinit()
```

#### Basic authentication
Basic authentication is supported by Client after username and password are set. In this case `Authorization` request header is filled up properly with encoded username and password as value:
```python
# Initialize HTTP Client with user and pass
HTTP_Client.init("http://httpbin.org/basic-auth/http_user/http_pass", auth=('user', 'pass'), callback=client_handler)
# Send request
HTTP_Client.send_request()
# Get the auth of Client
HTTP_Client.auth()
# Reset the auth for Client
HTTP_Client.auth("http_user", "http_pass")
# Send request the request again
HTTP_Client.send_request()
```

## HTTPS Client
To create an HTTPS (HTTP Secure or HTTP over TLS/SSL) Client using `HTTP_Client` module, the only thing that needs to be done is to be set the correct `url` in init method starting with `https://`. From that point, the whole SSL handshake process will be handled automatically after a request send. Request & Response Service of https://httpbin.org/ can be used for testing.

```python
# Initialize HTTP Client
HTTP_Client.init("http://httpbin.org/get", callback=client_callback)
```

```python
# Initialize HTTPS Client
HTTP_Client.init("https://httpbin.org/get", callback=client_callback)
```

## HTTP with socket
Basic connection using `ssl.wrap_socket()`.

```python

import socket
import ssl

s = socket.socket()
ss = ssl.wrap_socket(s)
ss.connect(socket.getaddrinfo('www.google.com', 443)[0][-1])
```

Below is an example using certificates with the blynk cloud.

Certificate was downloaded from the blynk examples [folder](https://github.com/wipy/wipy/tree/master/examples/blynk) and placed in `/flash/cert/` on the device.

```python

import socket
import ssl

s = socket.socket()
ss = ssl.wrap_socket(s, cert_reqs=ssl.CERT_REQUIRED, ca_certs='/flash/cert/ca.pem')
ss.connect(socket.getaddrinfo('cloud.blynk.cc', 8441)[0][-1])
```

For more info, check the [`ssl`](/firmwareapi/micropython/ussl) module in the API reference.
